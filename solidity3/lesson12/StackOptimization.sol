// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Stack {
    uint256[] private _a;

    // Функция для сортировки массива пузырьком с использованием стека для промежуточных данных
    function bubbleSort() external {
        uint256 n = _a.length;  // Кэшируем длину массива, чтобы не обращаться к хранилищу каждый раз

        // Если массив пустой или имеет один элемент, нет необходимости сортировать
        if (n <= 1) {
            return;
        }

        // Создаем копию массива в памяти, чтобы избежать постоянных обращений к хранилищу
        uint256[] memory aMem = _a;

        // Внешний цикл для проходов по массиву
        for (uint256 i = 0; i < n - 1; i++) {
            bool swapped = false;  // Оптимизация: если за проход не было обменов, массив уже отсортирован

            // Внутренний цикл для сравнения соседних элементов
            for (uint256 j = 0; j < n - 1 - i; j++) {
                uint256 current = aMem[j];   // Кэшируем текущее значение из памяти
                uint256 next = aMem[j + 1];  // Кэшируем следующее значение из памяти

                // Если текущий элемент больше следующего, меняем их местами
                if (current > next) {
                    aMem[j] = next;      // Обновляем текущее значение в памяти
                    aMem[j + 1] = current;  // Обновляем следующее значение в памяти
                    swapped = true;  // Устанавливаем флаг, что был произведён обмен
                }
            }

            // Если не было обменов, массив уже отсортирован
            if (!swapped) {
                break;
            }
        }

        // После завершения сортировки копируем данные из памяти обратно в хранилище
        _a = aMem;
    }

    // Функция для получения массива
    function getArray() external view returns (uint256[] memory) {
        return _a;
    }
}


// Копирование массива в память:
// Мы создаем копию массива _a в память, используя конструкцию uint256[] memory aMem = _a;. Все операции сортировки производятся с этой копией в памяти, что значительно сокращает количество обращений к хранилищу (storage).
// Работа с элементами через память (стек):
// Элементы массива теперь обрабатываются в стеке через кэширование значений в переменные current и next. Эти данные находятся в памяти, и запись в хранилище (storage) выполняется только один раз после завершения всей сортировки.
// Минимизация обращений к хранилищу:
// Весь массив сортируется в памяти, а результат записывается в хранилище только один раз в конце (_a = aMem;). Это значительно уменьшает количество дорогих операций чтения и записи в хранилище.
// Анализ затрат на газ:
// Чтение и запись в хранилище: Теперь хранилище используется только дважды: для чтения массива в память и для записи отсортированного массива обратно. Это уменьшает общее количество операций с хранилищем, которые занимают основную долю затрат газа.
// Операции в памяти: Все операции с элементами массива происходят в памяти (стеке), что значительно дешевле, чем работа с хранилищем. Затраты на газ для этих операций минимальны.
// Эффективность: Затраты на газ уменьшаются, особенно для больших массивов, так как число операций с хранилищем сведено к минимуму, а большая часть работы выполняется в оперативной памяти.