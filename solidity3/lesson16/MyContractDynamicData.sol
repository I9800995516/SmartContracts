// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyContract {
    uint256[] arr;

    // Функция для добавления нового элемента в массив
    function pushArrayElem(uint256 newElem) external {
        assembly {
            // Получаем текущую длину массива
            let length := sload(arr.slot)

            // Вычисляем слот для нового элемента
            let slot := add(arr.slot, length)

            // Сохраняем новое значение в вычисленный слот
            sstore(slot, newElem)

            // Обновляем длину массива
            sstore(arr.slot, add(length, 1))
        }
    }

    // Функция для получения элемента из массива
    function getElem(uint256 index) external view returns (uint256) {
        uint256 value;
        assembly {
            // Получаем длину массива
            let length := sload(arr.slot)

            // Проверяем, что индекс в пределах длины массива
            if iszero(lt(index, length)) {
                revert(0, 0)
            }

            // Вычисляем слот для элемента
            let slot := add(arr.slot, index)

            // Получаем значение из слота
            value := sload(slot)
        }
        return value;
    }
}

// 1. Массив `arr`: Это динамический массив типа uint256, который будет хранить добавленные элементы.
  
// 2. Функция `pushArrayElem`:
//    - Использует ассемблер для получения текущей длины массива с помощью sload(arr.slot).
//    - Вычисляет слот для нового элемента, добавляя длину к базовому слоту массива.
//    - Сохраняет новый элемент в вычисленный слот с помощью sstore.
//    - Обновляет длину массива, увеличивая её на 1.

// 3. Функция `getElem`:
//    - Получает длину массива и проверяет, что индекс находится в допустимых пределах.
//    - Вычисляет слот для элемента по индексу и загружает значение из этого слота.
//    - Возвращает значение элемента.

// Заключение

// Этот код демонстрирует, как можно использовать Yul и ассемблер для работы с динамическими массивами в Solidity. Он позволяет эффективно добавлять и получать элементы из массива, обеспечивая прямой доступ к памяти.